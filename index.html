<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8"/>
	<title>Geometry Processing Course</title>
	<meta name="author" content="Klint Qinami, Alec Jacobson"/>
<link rel="stylesheet" href=style.css>
</head>
<body>

<h1 id="geometryprocessing">Geometry Processing</h1>

<p>Winter Term 2017<br/>
CSC2521 [Topics in Computer Graphics: Geometry Processing]<br/>
Prof. Alec Jacobson </p>

<p><em>This course page is a work in progress. Stay tuned.</em></p>

<p>This geometry processing course focuses on developing and implementing
mathematically derived algorithms to manipulate virtual geometrical models.
Engineers, computer scientists, artists, physicists, architects,
neuroscientists, and curious students alike need these algorithms to be robust,
efficient, and visually pleasing. Even with such a variety of users processing
mesh geometry, there is a common user pipeline that emerges, and this course
will focus particularly on developing a cohesive understanding of each stage of
the pipeline.</p>

<h2 id="organization">Organization</h2>

<p>Students will attend lectures where exposition and mathematical derivations are
given, and are expected to complete weekly programming assignments implementing
derived algorithms. By the end of the semester, they should be able to have a
finalized creative piece of geometry that they can 3D print or use virtually,
utilizing their newly developed toolset. There also may be a short in-class
exam that should be relatively easy for students who attended lecture and
worked through the derivations.</p>

<h2 id="objectives">Objectives</h2>

<ol>
<li>Students should understand, derive, and implement solutions to the
 prominent challenges that arise in geometry processing applications.</li>
<li>Students should create a final creative project showcasing their
 implementation of the different processing algorithms.</li>
<li>Students should develop an understanding of the mathematical underpinnings
 of geometry processing including useful discretized operators and energies.</li>
<li>Students should develop a working knowledge of
 <a href="http://libigl.github.io/libigl/">libigl</a> to develop these algorithms without
 worrying about the grunt-work of
 <a href="https://en.wikipedia.org/wiki/OpenGL">OpenGL</a> viewers, quadrature, etc.</li>
</ol>

<h2 id="prerequisites">Prerequisites</h2>

<p>Students should have already taken <strong>Linear Algebra</strong> and <strong>Calculus</strong>.</p>

<p>Students should have already taken <strong>Introduction to Computer Science</strong> and
should be <em>proficient</em> in computer programming (in any language) and should
feel comfortable programming in <strong>C++</strong>.</p>

<p>While knowledge of <strong>Partial Differential Equations</strong> <em>is not required</em>, it will
certainly be very handy for derivations. A quick survey will be posted to help
students evaluate their readiness on these topics.</p>

<p>On the programming side, we will be coding mainly in <strong>C++</strong> and using a
miniature version of <a href="http://libigl.github.io/libigl/">libigl</a>, an open-source
geometry processing library. We will be using
<a href="http://eigen.tuxfamily.org">Eigen</a> for computational linear algebra, and
<a href="http://cmake.org">Cmake</a> for building the coding assignments.</p>

<h2 id="topics">Topics</h2>

<h3 id="1.acquisitionandreconstruction">1. Acquisition and Reconstruction</h3>

<p>Recent developments in scanning technology have dramatically increased our
capability to faithfully represent real-world objects virtually. Take the
Stanford Bunny, which can be scanned into a cloud of 3D coordinates by a laser scanner. </p>

<figure>
<img src="images/stanfordBunny.jpeg" alt="Consider a physical sculpture of a bunny made out of ceramic." />
<figcaption>Consider a physical sculpture of a bunny made out of ceramic.</figcaption>
</figure>

<figure>
<img src="images/stanfordBunnyCloud.jpg" alt="A laser scan of the bunny recreates the shape virtually as a cloud of points." />
<figcaption>A laser scan of the bunny recreates the shape virtually as a cloud of points.</figcaption>
</figure>

<p>We can convert the loose set of points into a closed surface composed of many
small triangles, a triangle mesh. Triangle meshes are the most popular discrete representation for continuous
surfaces on the computer. We can save the mesh to a file and load it into other
programs, for example <a href="http://libigl.github.io/libigl/">libigl</a>&#8217;s viewer:</p>

<figure>
<img src="images/reconstructedBunny.jpg" alt="The loose set of points is converted to a closed surface mesh." />
<figcaption>The loose set of points is converted to a closed surface mesh.</figcaption>
</figure>

<figure>
<img src="images/stanfordBunnyMesh.jpg" alt=" libigl's viewer renders the same bunny." />
<figcaption> <a href="http://libigl.github.io/libigl/">libigl</a>&#8217;s viewer renders the same bunny.</figcaption>
</figure>

<h3 id="2.surfacefairinganddenoising">2. Surface Fairing and Denoising</h3>

<p>If the scan was not so good, it is possible that the reconstructed mesh surface
is noisy. To illustrate this point, I have artificially introduced random noise
to the vertices of the bunny mesh. To fix this, I ran one step of implicit mean
curvature flow to smooth the bunny.</p>

<figure>
<img src="images/noisyBunny.jpg" alt="The bunny is corrupted by noise." />
<figcaption>The bunny is corrupted by noise.</figcaption>
</figure>

<figure>
<img src="images/smoothBunny.jpg" alt="Flowing the surface smooths out the noise." />
<figcaption>Flowing the surface smooths out the noise.</figcaption>
</figure>

<p>Continuing to smooth the bunny has an interesting effect. Eventually even low
frequency details disappear. And finally the bunny simply becomes a sphere.</p>

<figure>
<img src="images/reallySmoothedBunny.jpg" alt="The bunny loses low frequency details." />
<figcaption>The bunny loses low frequency details.</figcaption>
</figure>

<figure>
<img src="images/tooMuchSmoothing.jpg" alt="The bunny has become a simple sphere." />
<figcaption>The bunny has become a simple sphere.</figcaption>
</figure>

<h3 id="3.meshsimplification">3. Mesh Simplification</h3>

<p>Some algorithms demand such computing power that it may be reasonable to reduce
the complexity of our mesh by representing the geometry with fewer faces. Using
a greedy algorithm to assign edge collapse weights, we can achieve remarkably
nice results as shown on this fertility mesh</p>

<figure>
<img src="images/fertility.jpg" alt="The input Fertility model." />
<figcaption>The input Fertility model.</figcaption>
</figure>

<figure>
<img src="images/simplifiedFertility.jpg" alt="Mesh simplification maintains the geometry but removes triangles." />
<figcaption>Mesh simplification maintains the geometry but removes triangles.</figcaption>
</figure>

<figure>
<img src="images/reallySimplifiedFertility.jpg" alt="Further simplification can style maintain the shape but small artifacts
appear." />
<figcaption>Further simplification can style maintain the shape but small artifacts
appear.</figcaption>
</figure>

<figure>
<img src="images/simpleFertility.jpg" alt="Major simplification only captures the large features of the shape." />
<figcaption>Major simplification only captures the large features of the shape.</figcaption>
</figure>

<h3 id="4.meshparametrization">4. Mesh Parametrization</h3>

<p>Remarkably, using the smoothing machinery and tweaking a bit, we can create 2D
parametrizations for our 3D surfaces. If we have a mesh with a boundary, one
simple technique we can use is to map the boundary to the unit circle and then
place the remaining vertices within the disk in such a way that we minimize
displacement. Using the Dirichlet Energy as a measure, we can achieve harmonic
parametrization of this Lion mesh</p>
<center><img src="images/lion.jpg" alt="" /><img src="images/lionPlane.jpg" alt="" /></center>

<p>Because we restrict the boundary, this method can cause the parametrization to
warp angles and areas. Using a Least Squares Conformal Mapping, we can free the
boundary, show below on the left. Even beyond freeing the boundary, we can come
up with an As Rigid As Possible parametrization and use LSCM as a starting
point to improve upon, shown below on the right.</p>
<center><img src="images/harmonicLion.jpg" alt="" /><img src="images/arapLion.jpg" alt="" /></center>

<p>This parametrization can be used to overlay textures onto the original surface,
as it is already a planar representation of our three dimensional object.
Because of our choice of energies and physically based techniques, we can be
sure to get as little distortion in the mapping as we aimed for angle and area
preservation.</p>
<center><img src="images/checkerboardLion.jpg" alt="" /></center>

<h3 id="5.remeshing">5. Remeshing</h3>

<p>Even though it may seem like triangle meshes are in fact all we ever work with,
there is no reason to restrict ourselves. In fact, there are sometimes benefits
to working with quadrilateral meshes instead. Due to this, there is quite a bit
of literature on developing good remeshing algorithms. Here is an example of
the transformation from a triangle mesh to a quad mesh</p>
<center><img src="images/3holes.jpg" alt="" /><img src="images/remeshedHoles.jpg" alt="" /></center>

<h3 id="6.visualizingmeshfeatures">6. Visualizing Mesh Features</h3>

<p>The automatic detection of mesh features like symmetry, curvature, and
spin-axes are also useful tools for mesh analysis. Here is a plot of elliptic,
hyperbolic, and parabolic curvature on a bumpy square mesh</p>
<center> <img src="images/curvature.jpg" alt="" /> </center>

<h3 id="7.deformations">7. Deformations</h3>

<p>Mesh deformation techniques allow users to create new meshes by deforming
existing ones. This has especially important implications for character
animations. Handle-based deformations allow users to specify the positions of a
few predetermined handle points and allows the algorithm to deduce the rest.
Creating physically plausible deformations of characters is a challenging task,
and often sophisticated mathematical concepts are hidden behind simple uses
interfaces. Here&#8217;s a deformation of a knight character using an As Rigid As
Possible scheme</p>
<center><img src="images/knight.jpg" alt="" /><img src="images/deformedKnight.jpg" alt="" /></center>

<h2 id="amathematicalfoundation">A Mathematical Foundation</h2>

<p>Much of the framing for our techniques will be looking at the continuous
analogue of our problem and discretizing it in an intrinsic way, preserving
continuous theorems as much as possible. We will discretize continuous
operators like the Laplacian and the Gradient, and we will find adequate
representations of concepts like normal vectors and curvature. Perhaps
surprisingly we will see that there are many choices of discretization, each
with their own benefits and downsides, prompting us to choose appropriately for
the particular application.</p>

<h2 id="supplementaltextbook">Supplemental Textbook</h2>

<p><a href="https://www.amazon.ca/Polygon-Mesh-Processing-Mario-Botsch/dp/1568814267/"><em>Polygon Mesh
Processing</em></a>.
Mario Botsch, Leif Kobbelt, Mark Pauly, Pierre Alliez, and Bruno Levy, 2008.</p>

</body>
</html>
